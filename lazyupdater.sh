#!/bin/bash
# This script updates the pkgver value in a PKGBUILD file.
# Usage: ./update_pkgver.sh <new_version>
# Copyright Â© 2025 Alessandro Bernardello
set -e
# ARG_OPTIONAL_SINGLE([config],[c],[path to config],[/etc/lazyupdater.conf])
# ARG_OPTIONAL_BOOLEAN([gum],[],[use gum for nicer output],[on])
# ARG_OPTIONAL_BOOLEAN([quiet],[q],[suppress most output],[off])
# ARG_OPTIONAL_BOOLEAN([hooks],[],[process hooks],[on])
# ARG_VERBOSE([v])
# ARG_POSITIONAL_DOUBLEDASH([])
# ARG_POSITIONAL_SINGLE([version],[version to write in the pkgbuild])
# ARG_HELP([An helper tool to update pkgbuilds.])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='cqvh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_config="/etc/lazyupdater.conf"
_arg_gum="on"
_arg_quiet="off"
_arg_hooks="on"
_arg_verbose=0


print_help()
{
	printf '%s\n' "An helper tool to update pkgbuilds."
	printf 'Usage: %s [-c|--config <arg>] [--(no-)gum] [-q|--(no-)quiet] [--(no-)hooks] [-v|--verbose] [-h|--help] [--] <version>\n' "$0"
	printf '\t%s\n' "<version>: version to write in the pkgbuild"
	printf '\t%s\n' "-c, --config: path to config (default: '/etc/lazyupdater.conf')"
	printf '\t%s\n' "--gum, --no-gum: use gum for nicer output (on by default)"
	printf '\t%s\n' "-q, --quiet, --no-quiet: suppress most output (off by default)"
	printf '\t%s\n' "--hooks, --no-hooks: process hooks (on by default)"
	printf '\t%s\n' "-v, --verbose: Set verbose output (can be specified multiple times to increase the effect)"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		if test "$_key" = '--'
		then
			shift
			test $# -gt 0 || break
			_positionals+=("$@")
			_positionals_count=$((_positionals_count + $#))
			shift $(($# - 1))
			_last_positional="$1"
			break
		fi
		case "$_key" in
			-c|--config)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_config="$2"
				shift
				;;
			--config=*)
				_arg_config="${_key##--config=}"
				;;
			-c*)
				_arg_config="${_key##-c}"
				;;
			--no-gum|--gum)
				_arg_gum="on"
				test "${1:0:5}" = "--no-" && _arg_gum="off"
				;;
			-q|--no-quiet|--quiet)
				_arg_quiet="on"
				test "${1:0:5}" = "--no-" && _arg_quiet="off"
				;;
			-q*)
				_arg_quiet="on"
				_next="${_key##-q}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-q" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			--no-hooks|--hooks)
				_arg_hooks="on"
				test "${1:0:5}" = "--no-" && _arg_hooks="off"
				;;
			-v|--verbose)
				_arg_verbose=$((_arg_verbose + 1))
				;;
			-v*)
				_arg_verbose=$((_arg_verbose + 1))
				_next="${_key##-v}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'version'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_version "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# GLOBALS
GUM=false




# Prints according to verbosity level
# Levels: 1 - info (argbash makes it start from 1)
#         2 - debug
# Arguments:
#   $1: Text to print
#   $2: Min verbosity level
# Outputs:
#   Prints to stdout
logPrint() {
  if [ "$_arg_quiet" = "on" ]; then
	return
  fi
  local time
  time=$(date +"%T")
  local log_level=$_arg_verbose
  if [ "$log_level" -gt 2 ]; then
    log_level=2
  fi
  local log_level_name=""
  case "$2" in
	0) log_level_name="warn: " ;;
    1) log_level_name="info: " ;;
    2) log_level_name="debug: " ;;
  esac
  if [ "$log_level" -ge "$2" ]; then
	printf "[%s] %s%s\n" "$time" "$log_level_name" "$1"
  fi
}

# Checks if gum is available and enabled
# Inputs:
#   None
# Globals:
#   _arg_gum: gum flag
#   GUM: global flag
# Outputs:
#   None
checkGum() {
	if [ "$_arg_gum" = "on" ]; then
		if command -v gum >/dev/null 2>&1; then
			GUM=true
			logPrint "gum found, using it for nicer output" 2
		else
			logPrint "gum not found, falling back to standard output" 2
		fi
	else
		logPrint "gum disabled by user" 2
	fi
}

# Displays a gum spinner if gum is enabled
# Logs at info level otherwise
# Inputs:
#   $1: Message to display
#   $*: Command to run
# Globals:
#   GUM: global flag
# Outputs:
#   None
gumShim() {
	local message="$1"
	shift
	if $GUM; then
		gum spin --title "$message" -- "$@"
	else
		logPrint "$message" 1
		"$@"
	fi
}

main () {
	checkGum
	if [ ! -f _arg_config ] ; then
	  logPrint "Config file not found, using default settings" 0
	else
	  logPrint "Config file found, using settings" 1
	  # shellcheck source=/dev/null
	  source _arg_config
	fi

	# update pkgver before sourcing
	logPrint "Updating PKGBUILD" 1
	# shellcheck disable=SC2154
	gumShim "Updating PKGBUILD" sed -i "s/^\(pkgver=\).*/\1${_arg_version}/" PKGBUILD
	gumShim "Updating checksums" updpkgsums
	gumShim "Generating .SRCINFO" makepkg --printsrcinfo > .SRCINFO

	# shellcheck disable=SC1091
	source PKGBUILD

	gumShim "Building package" makepkg -f

	# shellcheck disable=SC2154
	# todo: use actual $ARCH instead of hardcoding
	# todo: read package extension from makepkg.conf
	sudo pacman -U "$pkgname"-"$pkgver"-"$pkgrel"-x86_64.pkg.tar.zst
}

main "$@"
# ] <-- needed because of Argbash
