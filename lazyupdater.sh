#!/bin/bash
# Copyright Â© 2025 Alessandro Bernardello
set -e
# ARG_OPTIONAL_SINGLE([config],[c],[path to config],[/etc/lazyupdater.conf])
# ARG_OPTIONAL_BOOLEAN([gum],[],[use gum for nicer output],[on])
# ARG_OPTIONAL_BOOLEAN([quiet],[q],[suppress most output],[off])
# ARG_OPTIONAL_BOOLEAN([check],[],[checks pkgbuild and built package with namcap],[on])
# ARG_OPTIONAL_BOOLEAN([build],[],[build the updated package],[on])
# ARG_OPTIONAL_BOOLEAN([install],[],[ install the package after building. disabling this implies disabling hooks],[on])
# ARG_OPTIONAL_BOOLEAN([hooks],[],[process hooks],[on])
# ARG_OPTIONAL_BOOLEAN([edit-config],[e],[edit the config file interactively],[off])
# ARG_VERBOSE([v])
# ARG_POSITIONAL_DOUBLEDASH([])
# ARG_POSITIONAL_SINGLE([version],[version to write in the pkgbuild])
# ARG_HELP([An helper tool to update pkgbuilds.])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die() {
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}

begins_with_short_option() {
	local first_option all_short_options='cqevh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_config="/etc/lazyupdater.conf"
_arg_gum="on"
_arg_quiet="off"
_arg_check="on"
_arg_build="on"
_arg_install="on"
_arg_hooks="on"
_arg_edit_config="off"
_arg_verbose=0

print_help() {
	printf '%s\n' "An helper tool to update pkgbuilds."
	printf 'Usage: %s [-c|--config <arg>] [--(no-)gum] [-q|--(no-)quiet] [--(no-)check] [--(no-)build] [--(no-)install] [--(no-)hooks] [-e|--(no-)edit-config] [-v|--verbose] [-h|--help] [--] <version>\n' "$0"
	printf '\t%s\n' "<version>: version to write in the pkgbuild"
	printf '\t%s\n' "-c, --config: path to config (default: '/etc/lazyupdater.conf')"
	printf '\t%s\n' "--gum, --no-gum: use gum for nicer output (on by default)"
	printf '\t%s\n' "-q, --quiet, --no-quiet: suppress most output (off by default)"
	printf '\t%s\n' "--check, --no-check: checks pkgbuild and built package with namcap (on by default)"
	printf '\t%s\n' "--build, --no-build: build the updated package (on by default)"
	printf '\t%s\n' "--install, --no-install:  install the package after building. disabling this implies disabling hooks (on by default)"
	printf '\t%s\n' "--hooks, --no-hooks: process hooks (on by default)"
	printf '\t%s\n' "-e, --edit-config, --no-edit-config: edit the config file interactively (off by default)"
	printf '\t%s\n' "-v, --verbose: Set verbose output (can be specified multiple times to increase the effect)"
	printf '\t%s\n' "-h, --help: Prints help"
}

parse_commandline() {
	_positionals_count=0
	while test $# -gt 0; do
		_key="$1"
		if test "$_key" = '--'; then
			shift
			test $# -gt 0 || break
			_positionals+=("$@")
			_positionals_count=$((_positionals_count + $#))
			shift $(($# - 1))
			_last_positional="$1"
			break
		fi
		case "$_key" in
		-c | --config)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_config="$2"
			shift
			;;
		--config=*)
			_arg_config="${_key##--config=}"
			;;
		-c*)
			_arg_config="${_key##-c}"
			;;
		--no-gum | --gum)
			_arg_gum="on"
			test "${1:0:5}" = "--no-" && _arg_gum="off"
			;;
		-q | --no-quiet | --quiet)
			_arg_quiet="on"
			test "${1:0:5}" = "--no-" && _arg_quiet="off"
			;;
		-q*)
			_arg_quiet="on"
			_next="${_key##-q}"
			if test -n "$_next" -a "$_next" != "$_key"; then
				{ begins_with_short_option "$_next" && shift && set -- "-q" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
			fi
			;;
		--no-check | --check)
			_arg_check="on"
			test "${1:0:5}" = "--no-" && _arg_check="off"
			;;
		--no-build | --build)
			_arg_build="on"
			test "${1:0:5}" = "--no-" && _arg_build="off"
			;;
		--no-install | --install)
			_arg_install="on"
			test "${1:0:5}" = "--no-" && _arg_install="off"
			;;
		--no-hooks | --hooks)
			_arg_hooks="on"
			test "${1:0:5}" = "--no-" && _arg_hooks="off"
			;;
		-e | --no-edit-config | --edit-config)
			_arg_edit_config="on"
			test "${1:0:5}" = "--no-" && _arg_edit_config="off"
			;;
		-e*)
			_arg_edit_config="on"
			_next="${_key##-e}"
			if test -n "$_next" -a "$_next" != "$_key"; then
				{ begins_with_short_option "$_next" && shift && set -- "-e" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
			fi
			;;
		-v | --verbose)
			_arg_verbose=$((_arg_verbose + 1))
			;;
		-v*)
			_arg_verbose=$((_arg_verbose + 1))
			_next="${_key##-v}"
			if test -n "$_next" -a "$_next" != "$_key"; then
				{ begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
			fi
			;;
		-h | --help)
			print_help
			exit 0
			;;
		-h*)
			print_help
			exit 0
			;;
		*)
			_last_positional="$1"
			_positionals+=("$_last_positional")
			_positionals_count=$((_positionals_count + 1))
			;;
		esac
		shift
	done
}

assign_positional_args() {
	local _positional_name _shift_for=$1
	_positional_names="_arg_version "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}; do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# Workaround for unsupported Argbash feature
handle_passed_args_count() {
	if [ "$_arg_edit_config" = "on" ]; then
		return
	fi
	local _required_args_string="'version'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}
handle_passed_args_count

# GLOBALS
GUM=false



# Prints according to verbosity level
# Levels: 1 - info (argbash makes it start from 1)
#         2 - debug
# Arguments:
#   $1: Text to print
#   $2: Min verbosity level
# Outputs:
#   Prints to stdout
log() {
	if [ "$_arg_quiet" = "on" ]; then
		return
	fi
	local log_level=$_arg_verbose
	if [ "$log_level" -gt 2 ]; then
		log_level=2
	fi
	local log_level_name=""
	case "$2" in
	0) log_level_name="warn" ;;
	1) log_level_name="info" ;;
	2) log_level_name="debug" ;;
	esac
	if $GUM; then
		gum log -l "$log_level_name" "$1"
	else
		local time
		time=$(date +"%T")
		if [ "$log_level" -ge "$2" ]; then
			printf "[%s] %s: %s\n" "$time" "${log_level_name^^}" "$1"
		fi
	fi
}

# Displays a gum spinner if gum is enabled
# Logs at info level otherwise
# Inputs:
#   $1: Message to display
#   $*: Command to run
# Globals:
#   GUM: global flag
# Outputs:
#   None
gumSpinner() {
	local message="$1"
	shift
	if $GUM; then
		local printArg=""
		if [ "$_arg_quiet" = "off" ]; then
			printArg="--show-output"
		fi
		gum spin --title "$message" "$printArg" -- "$@"
	else
		if [ "$_arg_quiet" = "off" ]; then
			log "$message" 1
			"$@"
		else
			"$@" >/dev/null 2>&1
		fi
	fi
}

# Installs a compiled package in the current directory
# Inputs:
#   None
# Globals:
#   None
# Outputs:
#   None
install() {
	# shellcheck disable=SC1091
	source PKGBUILD
	# shellcheck disable=SC1091
	source /etc/makepkg.conf
	# shellcheck disable=SC2154
	sudo pacman --noconfirm -U "$pkgname"-"$pkgver"-"$pkgrel"-"$CARCH""$PKGEXT"
}

# Reads config for HOOKDIR and runs hooks corresponding
# to the current package, if found
# Inputs:
# $1: Package name
# Globals:
# none
# Outputs:
# none
runHooks() {
	if [ ! -f "$_arg_config" ]; then
		log "Config file not found, skpping hooks" 0
		return
	else
		log "using config file: $_arg_config" 2
		# shellcheck source=/dev/null
		source _arg_config
	fi
	if [ -d "$HOOKDIR" ]; then
		log "$HOOKDIR does not exist or cannot be read, skipping hooks" 0
		return
	fi
	if [ -d "$HOOKDIR" ]; then
		log "$HOOKDIR does not exist or cannot be read, skipping hooks" 0
		return
	fi
	if [ ! -d "$HOOKDIR/$pkgname" ]; then
		log "No hooks found for $pkgname, skipping" 1
		return
	fi
	# populate an array with all hooks with extensions present in HOOKEXTS
	local hooks=()
	for ext in $HOOKEXTS; do
		hooks+=("$HOOKDIR/$pkgname/*$ext")
	done
	if [ ${#hooks[@]} -eq 0 ]; then
		log "No hooks found for $pkgname, skipping" 1
		return
	fi
	log "Running hooks for $pkgname" 1
	for hook in "${hooks[@]}"; do
		if [ -f "$hook" ]; then
			log "Running hook: $hook" 1
			gumSpinner "Running hook: $hook" bash "$hook"
		else
			log "Cannot access hook: $hook" 0
		fi
	done
}

# Bumps version in the PKGBUILD file, updates checksums and generates .SRCINFO
# Inputs:
#   None
# Globals:
#   _arg_version: version to write in the pkgbuild
# Outputs:
#   None
bumpVersion() {
	log "Updating PKGBUILD" 1
	# shellcheck disable=SC2154
	gumSpinner "Updating PKGBUILD" sed -i "s/^\(pkgver=\).*/\1${_arg_version}/" PKGBUILD
	gumSpinner "Updating checksums" updpkgsums
	gumSpinner "Generating .SRCINFO" makepkg --printsrcinfo >.SRCINFO
}

updatePkg() {
	bumpVersion
	if [ $_arg_check = "on" ]; then
		gumSpinner "Running namcap on PKGBUILD" namcap PKGBUILD
	fi
	if [ $_arg_build = "on" ]; then
		gumSpinner "Building package" makepkg -f
		if [ "$_arg_install" = "on" ]; then
			install
		fi
	fi
	if [ "$_arg_hooks" = "on" ]; then
		runHooks "$pkgname"
	fi
}

sanitizeFlags() {
	if [ "$_arg_verbose" -gt 0 ] && [ "$_arg_quiet" = "on" ]; then
		log "Quiet mode and verbose mode are mutually exclusive. Setting quiet mode to off" 0
		_arg_quiet="off"
	fi
	cascading_flags=(build install hooks)
	local cascading=false
	local previous_flag=""
	for flag in "${cascading_flags[@]}"; do
		var="_arg_${flag}"
		if [ $cascading ]; then
			log "Setting $flag to off since $previous_flag is off" 1
			eval "$var=off"
		fi
		if [ "${!var}" = "off" ]; then
			cascading=true
			previous_flag=$flag
		fi
	done
	if [ "$_arg_gum" = "on" ]; then
		if command -v gum >/dev/null 2>&1; then
			GUM=true
			log "gum found, using it for nicer output" 2
		else
			if [ "$_arg_edit_config" = "on" ]; then
				die "gum not found, please install it to use the interactive config editor" 1
			fi
			log "gum not found, falling back to standard output" 2
		fi
	else
		log "gum disabled by user" 2
	fi

}

createDefaultConfig() {
	local config_file="/etc/lazyupdater.conf"
	config_content=$(
		cat <<'EOF'
# Config file for lazyupdater
# This file gets directly sourced with bash, please don't put spaces in assignments
#
# HOOKDIR: Directory where hooks are stored.
# HOOKEXTS: Allowed extensions for hooks. All files matching this pattern will be executed.
#           Lazyupdate will simply execute the file(s), use shebangs and make sure files are executable
HOOKDIR="$HOME/repos/lzhooks"
HOOKEXTS=("*.sh" "*.bash" "*.zsh" "*.fish" "*.py")
EOF
	)
	if gum confirm "Automatic config creation requires sudo privileges. Do you want to proceed?"; then
		log "Creating default config file at $config_file" 1
		echo "$config_content" | sudo tee "$config_file" >/dev/null
	else
		echo "add the following lines to $config_file"
		echo "$config_content"
	fi
}

chooseEditor() {
	local installedEditors=()
	local sanEDITOR=""
	if [ -n "$EDITOR" ]; then
		installedEditors+=("$EDITOR [Default]")
		sanEDITOR=$EDITOR
	fi
	#https://wiki.archlinux.org/title/List_of_applications/Documents#Text_editors
	checkEditors=(
		"vim"
		"nano"
		"micro"
		"emacs"
		"gedit"
		"code"
		"zed"
		"kak"
		"helix"
		"nvim"
		"atom"
		"kate"
		"subl"
		"pluma"
		"leafpad"
	)
	for editor in "${checkEditors[@]}"; do
		if [ "$editor" != "$sanEDITOR" ] && command -v "$editor" >/dev/null 2>&1; then
			installedEditors+=("$editor")
		fi
	done

	selectedEditor=$(gum filter --placeholder "Choose an editor" --limit 1 "${installedEditors[@]}") #--height 20 --width 40 
	if [ -z "$selectedEditor" ]; then
		die "Internal error: no editor selected" 1
	fi
	echo "$selectedEditor"
}

createHookDir() {
	local hookdir="$1"
	if [ -z "$hookdir" ]; then
		die "Internal error: createHookDir(): hook directory not specified" 1
	fi
	if gum confirm "Want to clone an existing hook repo?"; then
		local repo_url
		repo_url=$(gum input --placeholder "Enter the URL of the hook repo")
		git clone "$repo_url" "$hookdir"
	else
		mkdir -p "$hookdir"
		log "Created hook directory: $hookdir" 1
	fi
}

editConfig() {
	if [ ! -f "$_arg_config" ]; then
		log "$_arg_config not found" 2
		if gum confirm "Config file not found, create a new one?"; then
			createDefaultConfig
		else
			die "Config file not found, please create one" 1
		fi
	fi
	editor=$(chooseEditor)
	if [ -z "$editor" ]; then
		die "Internal error: no editor selected" 1
	fi
	${editor} "$_arg_config" || die "Failed to open config file with $editor" 1
	# shellcheck disable=SC1090
	source "$_arg_config"
	if [ -z "$HOOKDIR" ]; then
		gum confirm "No HOOKDIR found in config file, do you want to create one?" && {
			while [ -z "$HOOKDIR" ]; do
				HOOKDIR=$(gum input --placeholder "Enter the path to the hooks directory")
			done
			echo "HOOKDIR=\"$HOOKDIR\"" >>"$config_file"
			createHookDir "$HOOKDIR"
		}
	fi
	if [ ! -d "$HOOKDIR" ]; then
		if (gum confirm "HOOKDIR is specified in the config file but does not exist. Do you want to create it?"); then 
			createHookDir "$HOOKDIR"
		else
			exit 0
		fi
	fi
}

main() {
	sanitizeFlags
	if [ "$_arg_edit_config" = "on" ]; then
		editConfig
	else
		updatePkg
	fi
	exit 0
}

main "$@"
# ] <-- needed because of Argbash
